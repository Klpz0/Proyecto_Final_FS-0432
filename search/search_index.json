{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentaci\u00f3n para el proyecto final de f\u00edsica computacional","text":"<p>En esta p\u00e1gina se resume la documentaci\u00f3n y funcionamiento de las implementaciones de diversos m\u00e9todos num\u00e9ricos para la simulaci\u00f3n del potencial en un capacitar de placas paralelas.</p> <p> </p>"},{"location":"#indice-de-contenidos","title":"Indice de contenidos:","text":""},{"location":"#tutorial","title":"Tutorial:","text":"<p>Implementaci\u00f3n y funcionamiento de los m\u00e9todos utilizados. </p>"},{"location":"#documentacion","title":"Documentaci\u00f3n:","text":"<p>Referencias de las funciones utilizadas en las distintas implementaciones.</p>"},{"location":"documentacion/","title":"Documentaci\u00f3n del m\u00e9todo de Jacobi","text":""},{"location":"documentacion/#src.serial_python.Laplace_Jacobi.condiciones_frontera","title":"<code>condiciones_frontera(phi)</code>","text":"<p>Aplica condiciones de frontera seg\u00fan el diagrama: - Bordes a 0 V - Electrodo izquierdo a +1\u202fV - Electrodo derecho a -1\u202fV</p> Source code in <code>src/serial_python/Laplace_Jacobi.py</code> <pre><code>def condiciones_frontera(phi):\n    \"\"\"\n    Aplica condiciones de frontera seg\u00fan el diagrama:\n    - Bordes a 0 V\n    - Electrodo izquierdo a +1\u202fV\n    - Electrodo derecho a -1\u202fV\n    \"\"\"\n    phi[0, :] = 0.0\n    phi[-1, :] = 0.0\n    phi[:, 0] = 0.0\n    phi[:, -1] = 0.0\n\n    n_filas, n_columnas = phi.shape\n    Long_x = n_columnas - 1 #longitud x\n    Long_y = n_filas - 1 #longitud y\n\n    electrodo_P = int(0.2 * Long_x) #electrodo positivo esta en el 30% desde la izquierda\n    electrodo_N = int(0.8 * Long_x) #electrodo positivo esta en el 70% desde la izquierda\n    inicio_fila = int(0.2 * Long_y) #inicio vertical en el 20%\n    final_fila = int(0.8 * Long_y)  #final vertical en el 80%\n\n    for i in range(inicio_fila, final_fila + 1):\n        phi[i, electrodo_P] = 1.0\n        phi[i, electrodo_N] = -1.0\n    return phi\n</code></pre>"},{"location":"documentacion/#src.serial_python.Laplace_Jacobi.jacobi_relaxation","title":"<code>jacobi_relaxation(N, tolerance)</code>","text":"<p>Ejecuta el m\u00e9todo de relajaci\u00f3n de Jacobi para resolver la ecuaci\u00f3n de Laplace en una grilla bidimensional de tama\u00f1o (N+1) x (N+1).</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int) </code> <p>Tama\u00f1o de la grilla (produce una grilla de (N+1) \u00d7 (N+1))</p> required <code>tolerance</code> <code>float) </code> <p>Criterio de convergencia para la diferencia m\u00e1xima entre iteraciones.</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>Arreglo 2D con los valores calculados de la funci\u00f3n potencial en la grilla.</p> <code>its</code> <code>int</code> <p>N\u00famero de iteraciones realizadas hasta alcanzar la tolerancia.</p> Source code in <code>src/serial_python/Laplace_Jacobi.py</code> <pre><code>def jacobi_relaxation(N, tolerance):\n    \"\"\"\n    Ejecuta el m\u00e9todo de relajaci\u00f3n de Jacobi para resolver la ecuaci\u00f3n de Laplace\n    en una grilla bidimensional de tama\u00f1o (N+1) x (N+1).\n\n    Args:\n        N (int) : Tama\u00f1o de la grilla (produce una grilla de (N+1) \u00d7 (N+1))\n        tolerance (float) : Criterio de convergencia para la diferencia m\u00e1xima entre iteraciones.\n\n    Returns:\n        phi (numpy.ndarray): Arreglo 2D con los valores calculados de la funci\u00f3n potencial en la grilla.\n        its (int): N\u00famero de iteraciones realizadas hasta alcanzar la tolerancia.\n    \"\"\"\n    phi = np.zeros((N + 1, N + 1), dtype=float)\n    phi = condiciones_frontera(phi)\n\n    delta = 1.0\n    its = 0\n\n    while delta &gt; tolerance:\n        its += 1\n        phi_new = laplace(phi)\n        delta = np.max(np.abs(phi - phi_new))\n        phi = phi_new\n\n    return phi, its\n</code></pre>"},{"location":"documentacion/#src.serial_python.Laplace_Jacobi.laplace","title":"<code>laplace(phi)</code>","text":"<p>Realiza una iteraci\u00f3n del m\u00e9todo de Jacobi usando el operador de Laplace.</p> <p>Esta funci\u00f3n calcula el laplaciano de la matriz de potencial <code>phi</code> sumando sus segundas derivadas en las direcciones x e y (previamente calculadas con bucles), y luego actualiza el potencial usando slicing solo para los puntos interiores.</p> <p>Las condiciones de frontera (por ejemplo, potencial fijo en los bordes o electrodos internos) se re-aplican despu\u00e9s de la actualizaci\u00f3n para asegurar la estabilidad.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>ndarray</code> <p>arreglo 2D que representa el potencial el\u00e9ctrico actual.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>arreglo 2D actualizado del potencial luego de una iteraci\u00f3n.</p> Source code in <code>src/serial_python/Laplace_Jacobi.py</code> <pre><code>def laplace(phi):\n    \"\"\"\n    Realiza una iteraci\u00f3n del m\u00e9todo de Jacobi usando el operador de Laplace.\n\n    Esta funci\u00f3n calcula el laplaciano de la matriz de potencial `phi`\n    sumando sus segundas derivadas en las direcciones x e y (previamente\n    calculadas con bucles), y luego actualiza el potencial usando\n    slicing solo para los puntos interiores.\n\n    Las condiciones de frontera (por ejemplo, potencial fijo en los bordes\n    o electrodos internos) se re-aplican despu\u00e9s de la actualizaci\u00f3n\n    para asegurar la estabilidad.\n\n    Args:\n        phi (ndarray): arreglo 2D que representa el potencial el\u00e9ctrico actual.\n\n    Returns:\n        (ndarray): arreglo 2D actualizado del potencial luego de una iteraci\u00f3n.\n    \"\"\"\n\n    d2x = segunda_derivada_x(phi)\n    d2y = segunda_derivada_y(phi)\n    laplaciano = d2x + d2y\n\n    phi_new = phi.copy()\n    phi_new[1:-1, 1:-1] = phi[1:-1, 1:-1] + 0.25 * laplaciano[1:-1, 1:-1]\n\n    phi_new = condiciones_frontera(phi_new)\n\n    return phi_new\n</code></pre>"},{"location":"documentacion/#src.serial_python.Laplace_Jacobi.segunda_derivada_x","title":"<code>segunda_derivada_x(phi)</code>","text":"<p>Calcula la segunda derivada en la direcci\u00f3n x de la matriz phi.</p> La derivada se calcula usando diferencias finitas centradas <p>d\u00b2\u03c6/dx\u00b2 \u2248 \u03c6[i+1,j] - 2\u03c6[i,j] + \u03c6[i-1,j]</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>ndarray</code> <p>Matriz 2D con los valores del potencial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Segunda derivada en x, misma forma que phi.</p> Source code in <code>src/serial_python/Laplace_Jacobi.py</code> <pre><code>def segunda_derivada_x(phi):\n    \"\"\"\n    Calcula la segunda derivada en la direcci\u00f3n x de la matriz phi.\n\n    La derivada se calcula usando diferencias finitas centradas:\n        d\u00b2\u03c6/dx\u00b2 \u2248 \u03c6[i+1,j] - 2\u03c6[i,j] + \u03c6[i-1,j]\n\n    Args:\n        phi (ndarray): Matriz 2D con los valores del potencial.\n\n    Returns:\n        (ndarray): Segunda derivada en x, misma forma que phi.\n    \"\"\"\n    d2x = np.zeros_like(phi)\n    for i in range(1, phi.shape[0] - 1):\n        for j in range(1, phi.shape[1] - 1):\n            d2x[i, j] = phi[i+1, j] - 2 * phi[i, j] + phi[i-1, j]\n    return d2x\n</code></pre>"},{"location":"documentacion/#src.serial_python.Laplace_Jacobi.segunda_derivada_y","title":"<code>segunda_derivada_y(phi)</code>","text":"<p>Calcula la segunda derivada en la direcci\u00f3n y de la matriz phi.</p> La derivada se calcula usando diferencias finitas centradas <p>d\u00b2\u03c6/dy\u00b2 \u2248 \u03c6[i,j+1] - 2\u03c6[i,j] + \u03c6[i,j-1]</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>ndarray</code> <p>Matriz 2D con los valores del potencial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Segunda derivada en y, misma forma que phi.</p> Source code in <code>src/serial_python/Laplace_Jacobi.py</code> <pre><code>def segunda_derivada_y(phi):\n    \"\"\"\n    Calcula la segunda derivada en la direcci\u00f3n y de la matriz phi.\n\n    La derivada se calcula usando diferencias finitas centradas:\n        d\u00b2\u03c6/dy\u00b2 \u2248 \u03c6[i,j+1] - 2\u03c6[i,j] + \u03c6[i,j-1]\n\n    Args:\n        phi (ndarray): Matriz 2D con los valores del potencial.\n\n    Returns:\n        (ndarray): Segunda derivada en y, misma forma que phi.\n    \"\"\"\n    d2y = np.zeros_like(phi)\n    for i in range(1, phi.shape[0] - 1):\n        for j in range(1, phi.shape[1] - 1):\n            d2y[i, j] = phi[i, j+1] - 2 * phi[i, j] + phi[i, j-1]\n    return d2y\n</code></pre>"},{"location":"documentacion/#documentacion-del-metodo-de-gaussseidel","title":"Documentaci\u00f3n del m\u00e9todo de Gauss\u2011Seidel","text":""},{"location":"documentacion/#src.serial_python.Laplace_Gauss_seidel.condiciones_frontera","title":"<code>condiciones_frontera(phi)</code>","text":"<p>Aplica condiciones de frontera: - Bordes exteriores a 0V - Electrodo izquierdo a +1\u202fV (centrado verticalmente) - Electrodo derecho a -1\u202fV (centrado verticalmente)</p> Source code in <code>src/serial_python/Laplace_Gauss_seidel.py</code> <pre><code>def condiciones_frontera(phi):\n    \"\"\"\n    Aplica condiciones de frontera:\n    - Bordes exteriores a 0V\n    - Electrodo izquierdo a +1\u202fV (centrado verticalmente)\n    - Electrodo derecho a -1\u202fV (centrado verticalmente)\n    \"\"\"\n    # Bordes exteriores\n    phi[0, :] = 0.0\n    phi[-1, :] = 0.0\n    phi[:, 0] = 0.0\n    phi[:, -1] = 0.0\n\n    # Calcular dimensiones\n    n_filas, n_columnas = phi.shape\n    Long_x = n_columnas - 1  # Longitud en x\n    Long_y = n_filas - 1     # Longitud en y\n\n    # Posiciones relativas (20% y 80% en x, 20% a 80% en y)\n    electrodo_P = int(round(0.2 * Long_x))   # Columna izquierda al 20%\n    electrodo_N = int(round(0.8 * Long_x))   # Columna derecha al 80%\n    inicio_fila = int(round(0.2 * Long_y))  # Inicio vertical al 20%\n    final_fila = int(round(0.8 * Long_y))    # Fin vertical al 80%\n\n    # Aplicar voltajes a electrodos\n    for i in range(inicio_fila, final_fila + 1):\n        phi[i, electrodo_P] = 1.0    # +1V\n        phi[i, electrodo_N] = -1.0  # -1V\n\n    return phi\n</code></pre>"},{"location":"documentacion/#src.serial_python.Laplace_Gauss_seidel.gauss_seidel_modified","title":"<code>gauss_seidel_modified(M, omega, tolerance)</code>","text":"<p>Resuelve la ecuaci\u00f3n de Laplace 2D con m\u00e9todo de Gauss-Seidel y relajaci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>M</code> <code>int</code> <p>Tama\u00f1o de la grilla (M+1 x M+1 puntos)</p> required <code>omega</code> <code>float</code> <p>Factor de sobre-relajaci\u00f3n (1 \u2264 omega \u2264 2)</p> required <code>tolerance</code> <code>float</code> <p>Tolerancia para convergencia</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>Potencial resultante</p> <code>its</code> <code>int</code> <p>N\u00famero de iteraciones</p> Source code in <code>src/serial_python/Laplace_Gauss_seidel.py</code> <pre><code>def gauss_seidel_modified(M, omega, tolerance):\n    \"\"\"\n    Resuelve la ecuaci\u00f3n de Laplace 2D con m\u00e9todo de Gauss-Seidel y relajaci\u00f3n.\n\n    Args:\n        M (int): Tama\u00f1o de la grilla (M+1 x M+1 puntos)\n        omega (float): Factor de sobre-relajaci\u00f3n (1 \u2264 omega \u2264 2)\n        tolerance (float): Tolerancia para convergencia\n\n    Returns: \n        phi (ndarray): Potencial resultante\n        its (int): N\u00famero de iteraciones\n    \"\"\"\n    # Inicializar matriz con condiciones de frontera\n    phi = np.zeros((M + 1, M + 1), dtype=float)\n    phi = condiciones_frontera(phi)\n    phi_old = phi.copy()\n\n\n    delta = 1.0\n    its = 0\n\n    while delta &gt; tolerance:\n        its += 1\n        # Guardar estado anterior para comparaci\u00f3n\n        phi_prev = phi.copy()\n\n        # Actualizar puntos interiores\n        for i in range(1, M):\n            for j in range(1, M):\n                # Calcular nuevo valor con Gauss-Seidel\n                new_val = 0.25 * (\n                    phi[i+1, j] + phi[i-1, j] + \n                    phi[i, j+1] + phi[i, j-1]\n                )\n                # Aplicar sobre-relajaci\u00f3n\n                phi[i, j] = (1 - omega) * phi[i, j] + omega * new_val\n\n        # Reforzar condiciones de frontera\n        phi = condiciones_frontera(phi)\n\n        # Calcular cambio m\u00e1ximo\n        delta = np.max(np.abs(phi - phi_prev))\n\n    return phi, its\n</code></pre>"},{"location":"documentacion/#src.serial_python.Laplace_Gauss_seidel.second_derivative_x","title":"<code>second_derivative_x(phi)</code>","text":"<p>Calcula la segunda derivada en x usando diferencias finitas centradas.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>ndarray</code> <p>Matriz 2D del potencial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Segunda derivada en x.</p> Source code in <code>src/serial_python/Laplace_Gauss_seidel.py</code> <pre><code>def second_derivative_x(phi):\n    \"\"\"\n    Calcula la segunda derivada en x usando diferencias finitas centradas.\n\n    Args:\n        phi (ndarray): Matriz 2D del potencial.\n\n    Returns:\n        (ndarray): Segunda derivada en x.\n    \"\"\"\n    d2x = np.zeros_like(phi)\n    for i in range(1, phi.shape[0] - 1):\n        for j in range(1, phi.shape[1] - 1):  # Corregido rango de j\n            d2x[i, j] = phi[i+1, j] - 2 * phi[i, j] + phi[i-1, j]\n    return d2x\n</code></pre>"},{"location":"documentacion/#src.serial_python.Laplace_Gauss_seidel.second_derivative_y","title":"<code>second_derivative_y(phi)</code>","text":"<p>Calcula la segunda derivada en y usando diferencias finitas centradas.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>ndarray</code> <p>Matriz 2D del potencial.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Segunda derivada en y.</p> Source code in <code>src/serial_python/Laplace_Gauss_seidel.py</code> <pre><code>def second_derivative_y(phi):\n    \"\"\"\n    Calcula la segunda derivada en y usando diferencias finitas centradas.\n\n    Args:\n        phi (ndarray): Matriz 2D del potencial.\n\n    Returns:\n        (ndarray): Segunda derivada en y.\n    \"\"\"\n    d2y = np.zeros_like(phi)\n    for i in range(1, phi.shape[0] - 1):  # Corregido rango de i\n        for j in range(1, phi.shape[1] - 1):\n            d2y[i, j] = phi[i, j+1] - 2 * phi[i, j] + phi[i, j-1]\n    return d2y\n</code></pre>"},{"location":"documentacion/#documentacion-del-metodo-de-sor","title":"Documentaci\u00f3n del m\u00e9todo de SOR","text":""},{"location":"documentacion/#src.serial_python.Jacobi_SOR.condiciones_frontera","title":"<code>condiciones_frontera(phi)</code>","text":"<p>Aplica condiciones de frontera seg\u00fan el diagrama: - Bordes a 0 V - Electrodo izquierdo a +1\u202fV - Electrodo derecho a -1\u202fV</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>ndarray</code> <p>Matriz 2D del potencial el\u00e9ctrico.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Matriz con condiciones de frontera aplicada.</p> Source code in <code>src/serial_python/Jacobi_SOR.py</code> <pre><code>def condiciones_frontera(phi):\n    \"\"\"\n    Aplica condiciones de frontera seg\u00fan el diagrama:\n    - Bordes a 0 V\n    - Electrodo izquierdo a +1\u202fV\n    - Electrodo derecho a -1\u202fV\n\n    Args:\n        phi (ndarray): Matriz 2D del potencial el\u00e9ctrico.\n\n    Returns:\n        (ndarray): Matriz con condiciones de frontera aplicada.\n    \"\"\"\n    phi[0, :] = 0.0\n    phi[-1, :] = 0.0\n    phi[:, 0] = 0.0\n    phi[:, -1] = 0.0\n\n    n_filas, n_columnas = phi.shape\n    Long_x = n_columnas - 1\n    Long_y = n_filas - 1\n\n    electrodo_P = int(0.2 * Long_x)\n    electrodo_N = int(0.8 * Long_x)\n    inicio_fila = int(0.2 * Long_y)\n    final_fila = int(0.8 * Long_y)\n\n    for i in range(inicio_fila, final_fila + 1):\n        phi[i, electrodo_P] = 1.0\n        phi[i, electrodo_N] = -1.0\n\n    return phi\n</code></pre>"},{"location":"documentacion/#src.serial_python.Jacobi_SOR.jacobi_sor_relaxation","title":"<code>jacobi_sor_relaxation(N, tolerance, omega)</code>","text":"<p>Ejecuta el m\u00e9todo de Jacobi-SOR para resolver la ecuaci\u00f3n de Laplace en una grilla bidimensional de tama\u00f1o (N+1) x (N+1).</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Tama\u00f1o de la grilla (produce una grilla de (N+1) \u00d7 (N+1))</p> required <code>tolerance</code> <code>float</code> <p>Criterio de convergencia.</p> required <code>omega</code> <code>float</code> <p>Factor de sobre-relajaci\u00f3n (1 &lt; omega &lt; 2)</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>ndarray</code> <p>Soluci\u00f3n final del potencial el\u00e9ctrico.</p> <code>its</code> <code>int</code> <p>N\u00famero de iteraciones realizadas.</p> Source code in <code>src/serial_python/Jacobi_SOR.py</code> <pre><code>def jacobi_sor_relaxation(N, tolerance, omega):\n    \"\"\"\n    Ejecuta el m\u00e9todo de Jacobi-SOR para resolver la ecuaci\u00f3n de Laplace\n    en una grilla bidimensional de tama\u00f1o (N+1) x (N+1).\n\n    Args:\n        N (int): Tama\u00f1o de la grilla (produce una grilla de (N+1) \u00d7 (N+1))\n        tolerance (float): Criterio de convergencia.\n        omega (float): Factor de sobre-relajaci\u00f3n (1 &lt; omega &lt; 2)\n\n    Returns:\n        phi (ndarray): Soluci\u00f3n final del potencial el\u00e9ctrico.\n        its (int): N\u00famero de iteraciones realizadas.\n    \"\"\"\n    phi = np.zeros((N + 1, N + 1), dtype=float)\n    phi = condiciones_frontera(phi)\n\n    delta = 1.0\n    its = 0\n\n    while delta &gt; tolerance:\n        its += 1\n        phi_new = laplace_jacobi_sor(phi, omega)\n        delta = np.max(np.abs(phi - phi_new))\n        phi = phi_new\n\n    return phi, its\n</code></pre>"},{"location":"documentacion/#src.serial_python.Jacobi_SOR.laplace_jacobi_sor","title":"<code>laplace_jacobi_sor(phi, omega)</code>","text":"<p>Realiza una iteraci\u00f3n del m\u00e9todo de Jacobi con sobre-relajaci\u00f3n (SOR) para resolver la ecuaci\u00f3n de Laplace (sin t\u00e9rmino fuente).</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>ndarray</code> <p>Matriz 2D actual del potencial.</p> required <code>omega</code> <code>float</code> <p>Factor de sobre-relajaci\u00f3n (1 &lt; omega &lt; 2).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Matriz actualizada del potencial tras una iteraci\u00f3n.</p> Source code in <code>src/serial_python/Jacobi_SOR.py</code> <pre><code>def laplace_jacobi_sor(phi, omega):\n    \"\"\"\n    Realiza una iteraci\u00f3n del m\u00e9todo de Jacobi con sobre-relajaci\u00f3n (SOR)\n    para resolver la ecuaci\u00f3n de Laplace (sin t\u00e9rmino fuente).\n\n    Args:\n        phi (ndarray): Matriz 2D actual del potencial.\n        omega (float): Factor de sobre-relajaci\u00f3n (1 &lt; omega &lt; 2).\n\n    Returns:\n        (ndarray): Matriz actualizada del potencial tras una iteraci\u00f3n.\n    \"\"\"\n    phi_new = phi.copy()\n\n    for i in range(1, phi.shape[0] - 1):\n        for j in range(1, phi.shape[1] - 1):\n            phi_est = 0.25 * (\n                phi[i+1, j] + phi[i-1, j] +\n                phi[i, j+1] + phi[i, j-1]\n            )\n            phi_new[i, j] = (1 - omega) * phi[i, j] + omega * phi_est\n\n    phi_new = condiciones_frontera(phi_new)\n    return phi_new\n</code></pre>"},{"location":"tutorial/","title":"Tutorial: M\u00e9todos de relajaci\u00f3n","text":""},{"location":"tutorial/#implementacion-del-metodo-de-relajacion-de-jacobi","title":"Implementaci\u00f3n del metodo de relajaci\u00f3n de Jacobi:","text":"<p>El m\u00e9todo de relajaci\u00f3n de Jacobi es un proceso iterativo utilizado para resolver sistemas de ecuaciones lineales, especialmente los que provienen de la discretizaci\u00f3n de ecuaciones diferenciales, como la de Laplace. En una grilla discreta de tama\u00f1o n\u00d7n, cada punto interior de la malla se actualiza en funci\u00f3n del promedio de sus vecinos, manteniendo fijos los valores de las fronteras seg\u00fan las condiciones del problema. Matem\u00e1ticamente se ve de la siguiente manera: </p> <p>\\(\\phi_{(x,y)} = \\frac{1}{4} \\cdot (\\phi_{(x + a,y)} + \\phi_{(x - a,y)} + \\phi_{(x,y + a)} + \\phi_{(x,y - a)})\\)</p> <p>En cada iteraci\u00f3n se calcula una nueva matriz con los valores actualizados, sin modificar la matriz original hasta completar todo el barrido. Este enfoque facilita la implementaci\u00f3n, ya que no hay dependencias entre los c\u00e1lculos de los distintos puntos en una misma iteraci\u00f3n, sin embargo resulta costoso computacionalmente. El proceso se detiene una vez se llega a la variaci\u00f3n entre valores de los puntos de la grilla est\u00e9 por de bajo de la tolerancia establecida en los par\u00e1metros iniciales establecidos.</p> M\u00e9todo de Jacobi <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\ndef segunda_derivada_x(phi):\n    d2x = np.zeros_like(phi)\n    for i in range(1, phi.shape[0] - 1):\n        for j in range(1, phi.shape[1] - 1):\n            d2x[i, j] = phi[i+1, j] - 2 * phi[i, j] + phi[i-1, j]\n    return d2x\n\ndef segunda_derivada_y(phi):\n    d2y = np.zeros_like(phi)\n    for i in range(1, phi.shape[0] - 1):\n        for j in range(1, phi.shape[1] - 1):\n            d2y[i, j] = phi[i, j+1] - 2 * phi[i, j] + phi[i, j-1]\n    return d2y\n\ndef condiciones_frontera(phi):\n    phi[0, :] = 0.0\n    phi[-1, :] = 0.0\n    phi[:, 0] = 0.0\n    phi[:, -1] = 0.0\n\n    n_filas, n_columnas = phi.shape\n    Long_x = n_columnas - 1\n    Long_y = n_filas - 1\n\n    electrodo_P = int(0.2 * Long_x)\n    electrodo_N = int(0.8 * Long_x)\n    inicio_fila = int(0.2 * Long_y)\n    final_fila = int(0.8 * Long_y)\n\n    for i in range(inicio_fila, final_fila + 1):\n        phi[i, electrodo_P] = 1.0\n        phi[i, electrodo_N] = -1.0\n    return phi\n\ndef laplace(phi):\n    d2x = segunda_derivada_x(phi)\n    d2y = segunda_derivada_y(phi)\n    laplaciano = d2x + d2y\n\n    phi_new = phi.copy()\n    phi_new[1:-1, 1:-1] = phi[1:-1, 1:-1] + 0.25 * laplaciano[1:-1, 1:-1]\n    phi_new = condiciones_frontera(phi_new)\n    return phi_new\n\ndef jacobi_relaxation(N, tolerance):\n    phi = np.zeros((N + 1, N + 1), dtype=float)\n    phi = condiciones_frontera(phi)\n\n    delta = 1.0\n    its = 0\n\n    while delta &gt; tolerance:\n        its += 1\n        phi_new = laplace(phi)\n        delta = np.max(np.abs(phi - phi_new))\n        phi = phi_new\n\n    return phi, its\n\njacobi_vals, iterations = jacobi_relaxation(100, 1e-5)\nprint(f\"Iteraciones: {iterations}\")\nplt.imshow(jacobi_vals, origin=\"lower\", cmap=\"jet\")\nplt.colorbar(label=\"Potencial \u03c6\")\nplt.show()\n</code></pre>"},{"location":"tutorial/#implementacion-del-metodo-de-relajacion-de-gauss-seidel","title":"Implementaci\u00f3n del m\u00e9todo de relajaci\u00f3n de Gauss-Seidel","text":"<p>El m\u00e9todo de Gauss-Seidel es una optimizaci\u00f3n del m\u00e9todo iterativo de Jacobi que permite una convergencia m\u00e1s r\u00e1pida al actualizar los valores directamente en la misma memoria durante cada iteraci\u00f3n. A diferencia de Jacobi, que calcula los nuevos valores sin modificar los anteriores hasta completar toda la grilla, Gauss-Seidel reutiliza inmediatamente los valores reci\u00e9n actualizados, lo que reduce el n\u00famero de iteraciones necesarias para alcanzar la convergencia. El esquema b\u00e1sico de actualizaci\u00f3n para resolver la ecuaci\u00f3n de Laplace por diferencias finitas centrales es:</p> <p>\\(\\phi_{(x,y)} = \\frac{1}{4} \\cdot (\\phi_{(x + a,y)} + \\phi_{(x - a,y)} + \\phi_{(x,y + a)} + \\phi_{(x,y - a)})\\)</p> <p>En este m\u00e9todo, los valores actualizados se escriben directamente sobre la matriz original, lo que introduce una dependencia entre los c\u00e1lculos dentro de la misma iteraci\u00f3n, dificultando su paralelizaci\u00f3n directa. Sin embargo, este enfoque reduce el uso de memoria y tiende a converger m\u00e1s r\u00e1pidamente que Jacobi.</p> M\u00e9todo de Gauss-Seidel <p>```python import numpy as np import matplotlib.pyplot as plt</p> <p>def condiciones_frontera(phi):     phi[0, :] = 0.0     phi[-1, :] = 0.0     phi[:, 0] = 0.0     phi[:, -1] = 0.0</p> <pre><code>n_filas, n_columnas = phi.shape\nLong_x = n_columnas - 1\nLong_y = n_filas - 1\n\nelectrodo_P = int(round(0.2 * Long_x))\nelectrodo_N = int(round(0.8 * Long_x))\ninicio_fila = int(round(0.2 * Long_y))\nfinal_fila = int(round(0.8 * Long_y))\n\nfor i in range(inicio_fila, final_fila + 1):\n    phi[i, electrodo_P] = 1.0\n    phi[i, electrodo_N] = -1.0\n\nreturn phi\n</code></pre> <p>def gauss_seidel_modified(M, omega, tolerance):     phi = np.zeros((M + 1, M + 1), dtype=float)     phi = condiciones_frontera(phi)</p> <pre><code>delta = 1.0\nits = 0\n\nwhile delta &gt; tolerance:\n    its += 1\n    phi_prev = phi.copy()\n\n    for i in range(1, M):\n        for j in range(1, M):\n            new_val = 0.25 * (\n                phi[i+1, j] + phi[i-1, j] + \n                phi[i, j+1] + phi[i, j-1]\n            )\n            phi[i, j] = (1 - omega) * phi[i, j] + omega * new_val\n\n    phi = condiciones_frontera(phi)\n    delta = np.max(np.abs(phi - phi_prev))\n\nreturn phi, its\n</code></pre> <p>gauss_seidel, iterations = gauss_seidel_modified(100, 1.5, 1e-5) print(f\"Iteraciones: {iterations}\")</p> <p>plt.figure(figsize=(8, 6)) plt.imshow(gauss_seidel, origin=\"lower\", cmap='jet') plt.colorbar(label=\"Potencial \u03c6\") plt.title(\"Soluci\u00f3n Gauss-Seidel de la Ecuaci\u00f3n de Laplace\") plt.xlabel(\"Posici\u00f3n X\") plt.ylabel(\"Posici\u00f3n Y\") plt.show() `````</p>"},{"location":"tutorial/#implementacion-del-metodo-de-sobre-relajacion-de-jacobi-over-relaxation","title":"Implementaci\u00f3n del m\u00e9todo de sobre relajaci\u00f3n de Jacobi (over-relaxation):","text":"<p>Una forma de acelerar la convergencia del m\u00e9todo de Jacobi es mediante el m\u00e9todo de Jacobi modificado, que incrementa el tama\u00f1o del paso en cada iteraci\u00f3n mediante un par\u00e1metro \\(\\omega\\). En lugar de avanzar poco a poco, se ajusta la actualizaci\u00f3n de \\(\\phi\\) para hacer pasos m\u00e1s grandes, lo que puede reducir el n\u00famero de iteraciones necesarias para aproximar la soluci\u00f3n. La actualizaci\u00f3n se define como:</p> <p>\\(\\phi'(x, y) = (1+\\omega) \\cdot \\left[\\frac{1}{4} \\cdot (\\phi(x + a, y) + \\phi(x - a, y) + \\phi(x, y + a) + \\phi(x, y - a))\\right] - \\omega \\phi(x, y)\\)</p> <p>Sin embargo, esta t\u00e9cnica no siempre es estable; la elecci\u00f3n adecuada del par\u00e1metro \u03c9\u03c9 es crucial y suele depender del problema espec\u00edfico para garantizar estabilidad y mejorar la velocidad de convergencia.</p>"},{"location":"tutorial/#causas-de-error-del-metodo-de-sobre-relajacion-de-jacobi","title":"Causas de error del m\u00e9todo de sobre-relajaci\u00f3n de Jacobi","text":"\\[ \\phi'(x, y) = \\frac{1}{4} \\left[ (\\omega + 1) \\left( \\phi(x + a, y) + \\phi(x - a, y) + \\phi(x, y + a) + \\phi(x, y - a) \\right) - \\omega\\phi(x, y) \\right] \\] <p>Este m\u00e9todo incluye un t\u00e9rmino \\(\\omega\\) que ayuda a acelerar la convergencia del mismo. Este m\u00e9todo num\u00e9rico no es \u00fatil para resolver el problema del capacitor y se debe a dos factores:</p> <ol> <li>Radio espectral de la matriz de iteraci\u00f3n \\(M\\) </li> <li>N\u00famero de condici\u00f3n de la matriz \\(A\\) </li> </ol> <p>Dado un sistema de la forma \\(A\\mathbf{x} = \\mathbf{b}\\), donde \\(A\\) es una matriz, \\(\\mathbf{x}\\) el vector de inc\u00f3gnitas y \\(\\mathbf{b}\\) el vector soluci\u00f3n, es posible implementar un m\u00e9todo iterativo como Jacobi o Gauss-Seidel. No obstante, estos m\u00e9todos dependen del radio espectral de su matriz de iteraci\u00f3n, de forma que la convergencia ocurre si y s\u00f3lo si:</p> \\[ \\text{Convergencia} \\iff \\rho(M) &lt; 1 \\] <p>(Donde \\(\\rho(M)\\) es una medida de la rapidez para corregir errores y converger).</p> <p>La matriz \\(M\\) se define como la descomposici\u00f3n de la matriz \\(A\\) del sistema inicial y depende de cada m\u00e9todo:</p> <ul> <li> <p>Jacobi: \\(M = D^{-1}(L + U)\\)</p> </li> <li> <p>Gauss-Seidel: \\(M = (D - L)^{-1}U\\)</p> </li> <li> <p>SOR (Relajaci\u00f3n Sucesiva): \\(M = [D - \\omega L]^{-1} [(1 - \\omega)D + \\omega U]\\)</p> </li> </ul> <p>El radio espectral de \\(M\\) es el m\u00e1ximo valor absoluto de sus valores propios.</p> <p>Por otra parte, el n\u00famero de condici\u00f3n de la matriz \\(A\\) mide qu\u00e9 tan bien condicionada est\u00e1. Si \\(k(A) \\gg 1\\), la matriz es sensible a perturbaciones y se dice \"mal condicionada\", generando errores en la soluci\u00f3n. Se define como:</p> \\[ k(A) = \\| A \\| \\cdot \\| A^T \\| \\] <p>Un sistema mal condicionado es num\u00e9ricamente inestable. Si \\(A\\) est\u00e1 mal condicionada, la estructura de \\(M\\) hereda esta dificultad y su radio espectral tiende a ser mayor, impidiendo la convergencia.</p> <p>Explicaci\u00f3n de la no convergencia en nuestro problema: El m\u00e9todo de Jacobi modificado no converge debido a que la matriz de coeficientes \\(A\\) est\u00e1 mal condicionada, con un n\u00famero de condici\u00f3n del orden de \\(10^3\\).</p> SOR Jacobi <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef condiciones_frontera(phi):\n    \"\"\"\n    Aplica condiciones de frontera seg\u00fan el diagrama:\n    - Bordes a 0 V\n    - Electrodo izquierdo a +1\u202fV\n    - Electrodo derecho a -1\u202fV\n\n    Args:\n        phi (ndarray): Matriz 2D del potencial el\u00e9ctrico.\n\n    Returns:\n        (ndarray): Matriz con condiciones de frontera aplicada.\n    \"\"\"\n    phi[0, :] = 0.0\n    phi[-1, :] = 0.0\n    phi[:, 0] = 0.0\n    phi[:, -1] = 0.0\n\n    n_filas, n_columnas = phi.shape\n    Long_x = n_columnas - 1\n    Long_y = n_filas - 1\n\n    electrodo_P = int(0.2 * Long_x)\n    electrodo_N = int(0.8 * Long_x)\n    inicio_fila = int(0.2 * Long_y)\n    final_fila = int(0.8 * Long_y)\n\n    for i in range(inicio_fila, final_fila + 1):\n        phi[i, electrodo_P] = 1.0\n        phi[i, electrodo_N] = -1.0\n\n    return phi\n\n\ndef laplace_jacobi_sor(phi, omega):\n    \"\"\"\n    Realiza una iteraci\u00f3n del m\u00e9todo de Jacobi con sobre-relajaci\u00f3n (SOR)\n    para resolver la ecuaci\u00f3n de Laplace (sin t\u00e9rmino fuente).\n\n    Args:\n        phi (ndarray): Matriz 2D actual del potencial.\n        omega (float): Factor de sobre-relajaci\u00f3n (1 &lt; omega &lt; 2).\n\n    Returns:\n        (ndarray): Matriz actualizada del potencial tras una iteraci\u00f3n.\n    \"\"\"\n    phi_new = phi.copy()\n\n    for i in range(1, phi.shape[0] - 1):\n        for j in range(1, phi.shape[1] - 1):\n            phi_est = 0.25 * (\n                phi[i+1, j] + phi[i-1, j] +\n                phi[i, j+1] + phi[i, j-1]\n            )\n            phi_new[i, j] = (1 - omega) * phi[i, j] + omega * phi_est\n\n    phi_new = condiciones_frontera(phi_new)\n    return phi_new\n\n\ndef jacobi_sor_relaxation(N, tolerance, omega):\n    \"\"\"\n    Ejecuta el m\u00e9todo de Jacobi-SOR para resolver la ecuaci\u00f3n de Laplace\n    en una grilla bidimensional de tama\u00f1o (N+1) x (N+1).\n\n    Args:\n        N (int): Tama\u00f1o de la grilla (produce una grilla de (N+1) \u00d7 (N+1))\n        tolerance (float): Criterio de convergencia.\n        omega (float): Factor de sobre-relajaci\u00f3n (1 &lt; omega &lt; 2)\n\n    Returns:\n        phi (ndarray): Soluci\u00f3n final del potencial el\u00e9ctrico.\n        its (int): N\u00famero de iteraciones realizadas.\n    \"\"\"\n    phi = np.zeros((N + 1, N + 1), dtype=float)\n    phi = condiciones_frontera(phi)\n\n    delta = 1.0\n    its = 0\n\n    while delta &gt; tolerance:\n        its += 1\n        phi_new = laplace_jacobi_sor(phi, omega)\n        delta = np.max(np.abs(phi - phi_new))\n        phi = phi_new\n\n    return phi, its\n\n\n# Par\u00e1metros y ejecuci\u00f3n\njacobi_vals, iterations = jacobi_sor_relaxation(100, 1e-5, omega=1.8)\nprint(f\"Iteraciones: {iterations}\")\n\n# Visualizaci\u00f3n\nplt.imshow(jacobi_vals, origin=\"lower\", cmap=\"jet\")\nplt.colorbar(label=\"Potencial \u03c6\")\nplt.title(\"Soluci\u00f3n de la ecuaci\u00f3n de Laplace con Jacobi-SOR\")\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.show()\n</code></pre>"}]}